# Auto-generated by Lumenary
##############################################################################
# Dependencies
##############################################################################


from fastapi import Depends, FastAPI, HTTPException, Request, status, Body, UploadFile, File, Form
from fastapi.staticfiles import StaticFiles
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import HTMLResponse, Response

from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, FileResponse, HTMLResponse, Response
from fastapi.exceptions import RequestValidationError
from fastapi.security import OAuth2PasswordBearer

import sys
import os
import asyncio
import logging
import traceback
import contextvars
import httpx
import jwt
import json
import requests
from pathlib import Path
import builtins

from datetime import datetime, date, time, timedelta
from concurrent.futures import ThreadPoolExecutor
from typing import Callable, Any, TypeVar, Awaitable, List, Optional, Dict, Union, Literal, Annotated, Tuple, Set
from functools import partial, wraps
from uuid import UUID
import uuid

from solar.access import User
from solar.media import MediaFile

from api.utils import get_swagger_ui_html
from api.models import TokenExchangeRequest, TokenResponse, TokenValidationRequest, LogoutResponse

OPENROUTER_API_KEY = os.environ.get("OPENROUTER_API_KEY")
ROUTER_BASE_URL = os.environ.get("ROUTER_BASE_URL")
SOLAR_APP_TOKEN_URL = f"{ROUTER_BASE_URL}/innerApp/oauth2/token"
SOLAR_APP_INTROSPECT_URL = f"{ROUTER_BASE_URL}/innerApp/oauth2/introspect"
REFRESH_TOKEN_COOKIE_NAME = "refresh_token"





from .models import GetUserProfileOutputSchema, CreateUserProfileOutputSchema, UpdateUserProfileOutputSchema, BodyUserServiceGetPublicUserProfile, GetPublicUserProfileOutputSchema, BodyUserServiceGetUserChains, GetUserChainsOutputSchema, BodyUserServiceGetUserMoves, GetUserMovesOutputSchema, CreateDanceChainOutputSchema, BodyChainServiceGetDanceChains, GetDanceChainsOutputSchema, BodyChainServiceGetDanceChain, GetDanceChainOutputSchema, BodyChainServiceGetChainMoves, GetChainMovesOutputSchema, AddMoveToChainOutputSchema, BodyChainServiceSearchChains, SearchChainsOutputSchema, BodyVotingServiceVoteOnMove, VoteOnMoveOutputSchema, BodyVotingServiceRemoveVote, RemoveVoteOutputSchema, BodyVotingServiceGetUserVoteOnMove, GetUserVoteOnMoveOutputSchema, BodyVotingServiceGetTopMoves, GetTopMovesOutputSchema, BodyVotingServiceGetMoveLeaderboardForChain, GetMoveLeaderboardForChainOutputSchema
from core import user_service, chain_service, voting_service
from core.ai_service import ai_service


###############################################################################
# Logging Setup
###############################################################################
import sys
from loguru import logger
from pathlib import Path
from typing import TypeVar
import traceback

def format_record(record):
    fmt = "{level:<5} | {message}"
    if record["exception"] is not None:
        exc_type, exc_value, exc_traceback = record["exception"]        
        tb_lines = traceback.extract_tb(exc_traceback)
        if tb_lines:
            last_frame = tb_lines[-1]
            error_info = (
                f'\nFile "{last_frame.filename}", line {last_frame.lineno}, in {last_frame.name}\n'
                f'  {last_frame.line}\n'
                f'{exc_type.__name__}: {exc_value}'
            )
            record["message"] += error_info
        
        record["exception"] = None
    
    return fmt + "\n"

logger.remove()
logger.add(
    sys.stderr,
    level="DEBUG",
    format=format_record,
    colorize=True
)

Path("../logs").mkdir(exist_ok=True)
logger.add(
    "../logs/fast_api.log",
    rotation="50 MB",
    retention="10 days",
    level="DEBUG",
    format=format_record
)

# need this to capture print statements
class InterceptHandler:
    def write(self, msg):
        if msg.strip():
            logger.info(msg.strip())
    
    def flush(self):
        pass

sys.stdout = InterceptHandler()

T = TypeVar('T')



##############################################################################
# General App
##############################################################################

app = FastAPI(
    title="New app â€” 6/14 @ 9:48 PM",
    docs_url=None
)

###############################################################################
# Simple Request Logging Middleware
###############################################################################

@app.middleware("http")
async def log_requests(request: Request, call_next):
    request_id = str(uuid.uuid4())[:8]
    
    with logger.contextualize(request_id=request_id):
        start_time = datetime.utcnow()
        
        try:
            response = await call_next(request)
            process_time = (datetime.utcnow() - start_time).total_seconds()
            if "HEAD /docs" not in request.url.path:
              logger.info(f"{request.method} {request.url.path} ({response.status_code}) - {process_time:.3f}s")
            return response
        except Exception as e:
            process_time = (datetime.utcnow() - start_time).total_seconds()
            logger.exception(f"{request.method} {request.url.path} - Failed after {process_time:.3f}s")
            raise
            
###############################################################################
# Error Handler
###############################################################################
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Global exception handler for unhandled errors"""
    logger.error(f"Unhandled exception on {request.method} {request.url.path}: {exc}", exc_info=True)
    
    # In production, don't expose error details
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": "Internal Server Error",
            "message": "An unexpected error occurred"
        }
    )
    
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Handle pydantic validation errors"""
    logger.error(f"Validation error on {request.url.path}: {exc.errors()}")
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "error": "Validation Error",
            "message": "Invalid request parameters",
            "details": exc.errors()
        }
    )
    
@app.exception_handler(Exception)
async def handle_errors(request: Request, exc: Exception):
    logger.exception(f"Unhandled error: {type(exc).__name__}: {exc}")
    return JSONResponse(
        status_code=500,
        content={"error": "Internal server error", "message": str(exc)}
    )

@app.exception_handler(RequestValidationError)
async def handle_validation_errors(request: Request, exc: RequestValidationError):
    logger.warning(f"Validation error: {exc.errors()}")
    return JSONResponse(
        status_code=422,
        content={"error": "Validation failed", "details": exc.errors()}
    )

# We need to put a token endpoint here, but we're injecting the token,
# so we'll just put a mock endpoint here.
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/mockedTokenEndpoint/")
ENV = os.environ.get("ENV", "deployment")

def get_auth_origins():
    if ENV == "sandbox":
        origins = [
            os.environ.get("SANDBOX_FRONTEND_URL", ""),
            os.environ.get("SANDBOX_BACKEND_URL", ""),
        ]
    else:
        origins = [os.environ.get("PUBLIC_DOMAIN", "")]
    
    return [origin for origin in origins if origin]

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

async def auth_cors_middleware(request: Request, call_next):
    if request.url.path.startswith("/api/auth"):
        auth_origins = get_auth_origins()
        origin = request.headers.get("origin", "")
        response = await call_next(request)
        
        # override the wildcard CORS settings with strict origin checking
        if origin in auth_origins:
            response.headers["Access-Control-Allow-Origin"] = origin
            response.headers["Access-Control-Allow-Credentials"] = "true"
            response.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
            response.headers["Access-Control-Allow-Headers"] = "Authorization, Content-Type, Accept"
            response.headers["Access-Control-Expose-Headers"] = "Set-Cookie"
        else:
            # unauthorized origins on auth routes, set CORS headers to blank or remove them
            response.headers["Access-Control-Allow-Origin"] = ""
            response.headers["Access-Control-Allow-Methods"] = ""
            response.headers["Access-Control-Allow-Headers"] = ""
            
        return response
    else:
        return await call_next(request)

# auth-specific middleware and logging middleware
app.middleware("http")(auth_cors_middleware)

# OPTIONS handler for auth endpoints
@app.options("/api/auth/{rest_of_path:path}", include_in_schema=False)
async def auth_options_handler(request: Request):
    auth_origins = get_auth_origins()
    origin = request.headers.get("origin", "")
    response = Response()
    
    if origin in auth_origins:
        response.headers["Access-Control-Allow-Origin"] = origin
        response.headers["Access-Control-Allow-Credentials"] = "true"
        response.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
        response.headers["Access-Control-Allow-Headers"] = "Authorization, Content-Type, Accept"
        response.headers["Access-Control-Max-Age"] = "3600"
    
    return response

@app.head("/docs", include_in_schema=False)
async def health_check():
    return {"status": "healthy"}
    
##############################################################################
# Synchronous Function Helpers
##############################################################################

thread_pool = ThreadPoolExecutor(max_workers=4)

async def run_sync_in_thread(func: Callable[..., Any], *args, **kwargs) -> Any:
    """Runs a synchronous function in a thread pool"""
    loop = asyncio.get_running_loop()
    return await loop.run_in_executor(
        thread_pool,
        partial(func, *args, **kwargs)
    )


##############################################################################
# Custom Docs
##############################################################################

@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " on Solar",
        swagger_ui_parameters={
            "persistAuthorization": False,
            "syntaxHighlight": {"theme": "obsidian"},
        }
    )

##############################################################################
# Auth Routes
##############################################################################

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        base_url = os.getenv("ROUTER_BASE_URL")
        if not base_url:
            raise HTTPException(status_code=500, detail="ROUTER_BASE_URL is not set, could not authenticate user")
        
        try:
            decoded_token = jwt.decode(token, options={"verify_signature": False})
            
            jti = decoded_token.get("jti")
            if not jti:
                raise HTTPException(status_code=401, detail="Invalid token format")
            
            exp = decoded_token.get("exp")
            if exp is not None and exp < datetime.utcnow().timestamp():
                raise HTTPException(status_code=401, detail="Token expired")
        
        except jwt.DecodeError:
            raise HTTPException(status_code=401, detail="Malformed token")
        
        token_url = f"{base_url}/innerApp/oauth2/introspect"
        async with httpx.AsyncClient(timeout=20.0) as client:
            response = await client.post(token_url, json={"token": jti, "token_type_hint": "access_token"})
            if response.status_code != 200:
                raise HTTPException(status_code=401, detail="Unauthorized")
            
            json_response = response.json()
            if not json_response.get("active", False):
                raise HTTPException(status_code=401, detail="Unauthorized")
            
            user_uuid = json_response.get("userUuid")
            email = json_response.get("email")
            if not user_uuid or not email:
                raise HTTPException(status_code=401, detail="Invalid user data")
            
            user = User(id=user_uuid, email=email)
            return user
    except HTTPException:
        raise
    except Exception as e:
        print(f"get_current_user failed with error: {type(e).__name__}")
        raise HTTPException(status_code=401, detail="Unauthorized")

def extract_domain(url):
    if not url:
        return None
    
    # Remove protocol
    if url.startswith("http://"):
        url = url[7:]
    elif url.startswith("https://"):
        url = url[8:]
    
    # Remove trailing slash
    if url.endswith("/"):
        url = url[:-1]
    
    return url

@app.post('/api/auth/token', response_model=TokenResponse, include_in_schema=False)
async def exchange_token(request: Request, body: TokenExchangeRequest = Body(...)):    
    try:
        params = body.model_dump(exclude_none=True)
        if params.get("grant_type") == REFRESH_TOKEN_COOKIE_NAME:
            refresh_token = request.cookies.get(REFRESH_TOKEN_COOKIE_NAME)
            if not refresh_token:
                return JSONResponse(
                    status_code=401,
                    content={
                        "status": "auth_required",
                        "message": "Authentication required",
                        "token_type": "bearer",
                        "access_token": "",
                        "expires_in": 0
                    }
                )

            params[REFRESH_TOKEN_COOKIE_NAME] = refresh_token
        
        if params.get("grant_type") == REFRESH_TOKEN_COOKIE_NAME and params.get(REFRESH_TOKEN_COOKIE_NAME):
            try:
                refresh_token = params[REFRESH_TOKEN_COOKIE_NAME]
                payload = jwt.decode(refresh_token, options={"verify_signature": False})
                
                if payload and payload.get("jti"):
                    params[REFRESH_TOKEN_COOKIE_NAME] = payload["jti"]
            except Exception as e:
                logger.warning("Error extracting JTI from refresh token")

        response = requests.post(
            SOLAR_APP_TOKEN_URL,
            json=params,
            headers={"Content-Type": "application/json", "Accept": "application/json"}
        )
        
        if not response.ok:
            return JSONResponse(
                    status_code=401,
                    content={
                        "status": "auth_required",
                        "message": "Authorization code invalid or expired",
                        "token_type": "bearer",
                        "access_token": "",
                        "expires_in": 0
                    }
                )
        
        tokens = response.json()
        
        # Safe null check for access token
        access_token = tokens.get("access_token")
        if not access_token:
            return HTTPException(status_code=401, detail="Received incomplete token data from server")
        
        token_response = TokenResponse(
            access_token=access_token,
            token_type=tokens.get("token_type", "bearer"),
            expires_in=tokens.get("expires_in", 3600)
        )
        
        content = token_response.model_dump()
        api_response = JSONResponse(content=content)
        
        # Safe null check for refresh token
        refresh_token_value = tokens.get(REFRESH_TOKEN_COOKIE_NAME)
        if refresh_token_value:
            if ENV == "sandbox" and not os.environ.get("SANDBOX_BACKEND_URL", None):
              return HTTPException(status_code=401, detail="Token exchange failed: sandbox frontend URL not set")
            
            if ENV == "deployment" and not os.environ.get("PUBLIC_DOMAIN", None):
              return HTTPException(status_code=401, detail="Token exchange failed: public domain not set")
            
            domain = None
            if ENV == "sandbox":
                domain = extract_domain(os.environ.get("SANDBOX_BACKEND_URL"))
            else:
                domain = extract_domain(os.environ.get("PUBLIC_DOMAIN"))

            api_response.set_cookie(
                key=REFRESH_TOKEN_COOKIE_NAME,
                value=refresh_token_value,
                httponly=True,
                secure=True,
                samesite="none" if ENV == "sandbox" else "strict",
                domain=domain,
                path="/api/auth"
            )
        
        return api_response
        
    except Exception as e:
        return HTTPException(status_code=401, detail=f"Token exchange failed: {str(e)}")


@app.post('/api/auth/logout', response_model=LogoutResponse, include_in_schema=False)
async def logout():
    response = JSONResponse(content={"success": True})
    
    if ENV == "sandbox" and not os.environ.get("SANDBOX_BACKEND_URL", None):
      return HTTPException(status_code=401, detail="Logout failed: sandbox frontend URL not set")
    
    if ENV == "deployment" and not os.environ.get("PUBLIC_DOMAIN", None):
      return HTTPException(status_code=401, detail="Logout failed: public domain not set")
    
    domain = None
    if ENV == "sandbox":
        domain = extract_domain(os.environ.get("SANDBOX_BACKEND_URL"))
    else:
        domain = extract_domain(os.environ.get("PUBLIC_DOMAIN"))
    
    response.delete_cookie(
        key=REFRESH_TOKEN_COOKIE_NAME,
        path="/api/auth",
        secure=True,
        httponly=True,
        samesite="none" if ENV == "sandbox" else "strict",
        domain=domain,
    )
    
    return response


##############################################################################
# Normal Routes
##############################################################################






@app.post('/api/user_service/get_user_profile', response_model=GetUserProfileOutputSchema, operation_id='user_service_get_user_profile')
async def user_service_get_user_profile(current_user: User = Depends(get_current_user)) -> GetUserProfileOutputSchema:
    """
    Get the current user&#39;s profile.
    """
    response = await run_sync_in_thread(user_service.get_user_profile, user=current_user)
    return response
    
    




@app.post('/api/user_service/create_user_profile', response_model=CreateUserProfileOutputSchema, operation_id='user_service_create_user_profile')
async def user_service_create_user_profile(avatar: Optional[UploadFile] = File(None), bio: Optional[str] = Form(None), dance_styles: Optional[str] = Form(None), display_name: Optional[str] = Form(None), location: Optional[str] = Form(None), username: str = Form(...), current_user: User = Depends(get_current_user)) -> CreateUserProfileOutputSchema:
    """
    Create a user profile for the authenticated user.
    """
    # Download avatar from the client
    if avatar is not None:
        content_type = avatar.content_type or "application/octet-stream"
        contents = await avatar.read()
        file_size = len(contents)
        avatar = MediaFile(size=file_size, mime_type=content_type, bytes=contents)

    response = await run_sync_in_thread(user_service.create_user_profile, user=current_user, username=username, display_name=display_name, bio=bio, avatar=avatar, location=location, dance_styles=dance_styles)
    return response
    
    




@app.post('/api/user_service/update_user_profile', response_model=UpdateUserProfileOutputSchema, operation_id='user_service_update_user_profile')
async def user_service_update_user_profile(avatar: Optional[UploadFile] = File(None), bio: Optional[str] = Form(None), dance_styles: Optional[str] = Form(None), display_name: Optional[str] = Form(None), location: Optional[str] = Form(None), current_user: User = Depends(get_current_user)) -> UpdateUserProfileOutputSchema:
    """
    Update the current user&#39;s profile.
    """
    # Download avatar from the client
    if avatar is not None:
        content_type = avatar.content_type or "application/octet-stream"
        contents = await avatar.read()
        file_size = len(contents)
        avatar = MediaFile(size=file_size, mime_type=content_type, bytes=contents)

    response = await run_sync_in_thread(user_service.update_user_profile, user=current_user, display_name=display_name, bio=bio, avatar=avatar, location=location, dance_styles=dance_styles)
    return response
    
    




@app.post('/api/user_service/get_public_user_profile', response_model=GetPublicUserProfileOutputSchema, operation_id='user_service_get_public_user_profile')
async def user_service_get_public_user_profile(body: BodyUserServiceGetPublicUserProfile = Body(...)) -> GetPublicUserProfileOutputSchema:
    """
    Get a user&#39;s public profile by username.
    """
    response = await run_sync_in_thread(user_service.get_public_user_profile, username=body.username)
    return response
    
    




@app.post('/api/user_service/get_user_chains', response_model=GetUserChainsOutputSchema, operation_id='user_service_get_user_chains')
async def user_service_get_user_chains(body: BodyUserServiceGetUserChains = Body(...)) -> GetUserChainsOutputSchema:
    """
    Get all dance chains created by a specific user.
    """
    response = await run_sync_in_thread(user_service.get_user_chains, username=body.username)
    return response
    
    




@app.post('/api/user_service/get_user_moves', response_model=GetUserMovesOutputSchema, operation_id='user_service_get_user_moves')
async def user_service_get_user_moves(body: BodyUserServiceGetUserMoves = Body(...)) -> GetUserMovesOutputSchema:
    """
    Get all moves submitted by a specific user.
    """
    response = await run_sync_in_thread(user_service.get_user_moves, username=body.username)
    return response
    
    




@app.post('/api/chain_service/create_dance_chain', response_model=CreateDanceChainOutputSchema, operation_id='chain_service_create_dance_chain')
async def chain_service_create_dance_chain(category: str = Form(...), description: str = Form(...), max_moves: int = Form(10), title: str = Form(...), video: UploadFile = File(...), current_user: User = Depends(get_current_user)) -> CreateDanceChainOutputSchema:
    """
    Create a new dance chain with the initial move.
    """
    # Download video from the client
    if video is not None:
        content_type = video.content_type or "application/octet-stream"
        contents = await video.read()
        file_size = len(contents)
        video = MediaFile(size=file_size, mime_type=content_type, bytes=contents)

    response = await run_sync_in_thread(chain_service.create_dance_chain, user=current_user, title=title, description=description, category=category, video=video, max_moves=max_moves)
    return response
    
    




@app.post('/api/chain_service/get_dance_chains', response_model=GetDanceChainsOutputSchema, operation_id='chain_service_get_dance_chains')
async def chain_service_get_dance_chains(body: BodyChainServiceGetDanceChains = Body(...)) -> GetDanceChainsOutputSchema:
    """
    Get dance chains with optional category filter.
    """
    response = await run_sync_in_thread(chain_service.get_dance_chains, category=body.category, limit=body.limit, offset=body.offset)
    return response
    
    




@app.post('/api/chain_service/get_dance_chain', response_model=GetDanceChainOutputSchema, operation_id='chain_service_get_dance_chain')
async def chain_service_get_dance_chain(body: BodyChainServiceGetDanceChain = Body(...)) -> GetDanceChainOutputSchema:
    """
    Get a specific dance chain by ID.
    """
    response = await run_sync_in_thread(chain_service.get_dance_chain, chain_id=body.chain_id)
    return response
    
    




@app.post('/api/chain_service/get_chain_moves', response_model=GetChainMovesOutputSchema, operation_id='chain_service_get_chain_moves')
async def chain_service_get_chain_moves(body: BodyChainServiceGetChainMoves = Body(...)) -> GetChainMovesOutputSchema:
    """
    Get all moves for a specific chain in order.
    """
    response = await run_sync_in_thread(chain_service.get_chain_moves, chain_id=body.chain_id)
    return response
    
    




@app.post('/api/chain_service/add_move_to_chain', response_model=AddMoveToChainOutputSchema, operation_id='chain_service_add_move_to_chain')
async def chain_service_add_move_to_chain(chain_id: uuid.UUID = Form(...), video: UploadFile = File(...), current_user: User = Depends(get_current_user)) -> AddMoveToChainOutputSchema:
    """
    Add a new move to an existing dance chain.
    """
    # Download video from the client
    if video is not None:
        content_type = video.content_type or "application/octet-stream"
        contents = await video.read()
        file_size = len(contents)
        video = MediaFile(size=file_size, mime_type=content_type, bytes=contents)

    response = await run_sync_in_thread(chain_service.add_move_to_chain, user=current_user, chain_id=chain_id, video=video)
    return response
    
    




@app.post('/api/chain_service/search_chains', response_model=SearchChainsOutputSchema, operation_id='chain_service_search_chains')
async def chain_service_search_chains(body: BodyChainServiceSearchChains = Body(...)) -> SearchChainsOutputSchema:
    """
    Search for dance chains by title or description.
    """
    response = await run_sync_in_thread(chain_service.search_chains, query=body.query, limit=body.limit)
    return response
    
    




@app.post('/api/voting_service/vote_on_move', response_model=VoteOnMoveOutputSchema, operation_id='voting_service_vote_on_move')
async def voting_service_vote_on_move(body: BodyVotingServiceVoteOnMove = Body(...), current_user: User = Depends(get_current_user)) -> VoteOnMoveOutputSchema:
    """
    Vote on a specific move. vote_type should be &#39;up&#39; or &#39;down&#39;.
    """
    response = await run_sync_in_thread(voting_service.vote_on_move, user=current_user, move_id=body.move_id, vote_type=body.vote_type)
    return response
    
    




@app.post('/api/voting_service/remove_vote', response_model=RemoveVoteOutputSchema, operation_id='voting_service_remove_vote')
async def voting_service_remove_vote(body: BodyVotingServiceRemoveVote = Body(...), current_user: User = Depends(get_current_user)) -> RemoveVoteOutputSchema:
    """
    Remove a user&#39;s vote from a move.
    """
    response = await run_sync_in_thread(voting_service.remove_vote, user=current_user, move_id=body.move_id)
    return response
    
    




@app.post('/api/voting_service/get_user_vote_on_move', response_model=GetUserVoteOnMoveOutputSchema, operation_id='voting_service_get_user_vote_on_move')
async def voting_service_get_user_vote_on_move(body: BodyVotingServiceGetUserVoteOnMove = Body(...), current_user: User = Depends(get_current_user)) -> GetUserVoteOnMoveOutputSchema:
    """
    Get the current user&#39;s vote on a specific move.
    """
    response = await run_sync_in_thread(voting_service.get_user_vote_on_move, user=current_user, move_id=body.move_id)
    return response
    
    




@app.post('/api/voting_service/get_top_moves', response_model=GetTopMovesOutputSchema, operation_id='voting_service_get_top_moves')
async def voting_service_get_top_moves(body: BodyVotingServiceGetTopMoves = Body(...)) -> GetTopMovesOutputSchema:
    """
    Get the top-voted moves across all chains.
    """
    response = await run_sync_in_thread(voting_service.get_top_moves, limit=body.limit)
    return response
    
    




@app.post('/api/voting_service/get_move_leaderboard_for_chain', response_model=GetMoveLeaderboardForChainOutputSchema, operation_id='voting_service_get_move_leaderboard_for_chain')
async def voting_service_get_move_leaderboard_for_chain(body: BodyVotingServiceGetMoveLeaderboardForChain = Body(...)) -> GetMoveLeaderboardForChainOutputSchema:
    """
    Get moves for a specific chain ranked by votes.
    """
    response = await run_sync_in_thread(voting_service.get_move_leaderboard_for_chain, chain_id=body.chain_id)
    return response


##############################################################################
# AI-Powered Features (Cerebras + Llama)
##############################################################################

@app.post('/api/ai/generate_challenge', operation_id='ai_generate_challenge')
async def ai_generate_challenge(
    theme: str = Form(..., description="Theme for the challenge (e.g., 'hip-hop', 'freestyle', 'latin')"),
    difficulty: str = Form(..., description="Difficulty level: 'easy', 'medium', or 'hard'")
) -> Dict:
    """
    Generate a complete dance challenge using AI.
    Uses Cerebras-powered Llama for ultra-fast generation.
    Returns structured challenge with performance metrics.
    """
    try:
        result = await run_sync_in_thread(
            ai_service.generate_challenge,
            theme=theme,
            difficulty=difficulty
        )
        return result
    except Exception as e:
        logger.exception("AI challenge generation failed")
        raise HTTPException(status_code=500, detail=f"AI generation failed: {str(e)}")


@app.post('/api/ai/coach_commentary', operation_id='ai_coach_commentary')
async def ai_coach_commentary(
    verification_score: float = Form(..., description="Move verification score (0-1)"),
    duration: float = Form(..., description="Move duration in seconds"),
    move_number: int = Form(..., description="Move number in chain")
) -> Dict:
    """
    Get AI coach commentary on a dance move performance.
    Uses Cerebras for real-time (<300ms) feedback.
    """
    try:
        result = await run_sync_in_thread(
            ai_service.generate_coach_commentary,
            verification_score=verification_score,
            duration=duration,
            move_number=move_number
        )
        return result
    except Exception as e:
        logger.exception("AI coach commentary failed")
        raise HTTPException(status_code=500, detail=f"AI commentary failed: {str(e)}")


@app.post('/api/ai/describe_move', operation_id='ai_describe_move')
async def ai_describe_move(
    body: Dict = Body(..., description="Pose analysis data with position, arms, legs, energy")
) -> Dict:
    """
    Generate natural language description of a dance move.
    Lightning-fast using Cerebras + Llama-8B.
    """
    try:
        result = await run_sync_in_thread(
            ai_service.describe_move,
            pose_analysis=body
        )
        return result
    except Exception as e:
        logger.exception("AI move description failed")
        raise HTTPException(status_code=500, detail=f"AI description failed: {str(e)}")


@app.post('/api/ai/viral_caption', operation_id='ai_viral_caption')
async def ai_viral_caption(
    chain_title: str = Form(..., description="Dance chain title"),
    category: str = Form(..., description="Dance category"),
    participant_count: int = Form(..., description="Number of participants")
) -> Dict:
    """
    Generate viral-worthy social media caption for a dance challenge.
    Optimized for Farcaster and social sharing.
    """
    try:
        result = await run_sync_in_thread(
            ai_service.generate_viral_caption,
            chain_title=chain_title,
            category=category,
            participant_count=participant_count
        )
        return result
    except Exception as e:
        logger.exception("AI caption generation failed")
        raise HTTPException(status_code=500, detail=f"AI caption failed: {str(e)}")


@app.get('/api/ai/performance_metrics', operation_id='ai_performance_metrics')
async def ai_performance_metrics() -> Dict:
    """
    Get AI service performance metrics.
    Shows Cerebras speed advantage and usage statistics.
    Perfect for demo purposes - displays 8x speedup vs typical cloud.
    """
    try:
        metrics = ai_service.get_performance_metrics()
        return metrics
    except Exception as e:
        logger.exception("Failed to get AI metrics")
        raise HTTPException(status_code=500, detail=f"Metrics retrieval failed: {str(e)}")
